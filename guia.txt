Instalando angular via npm:
    npm install -g @angular/cli

Criar a primeira aplicação:
    ng new tarefas      <<--- tarefas é o nome da aplicação

Ao criar a aplicação com o angular cli, para iniciar um simples servidor e verificar o funcionamento:
    ng serve --open     <<--- Isso irá abrir o browser em http://localhost:4200/

A estrutura de pastas criada ficará da seguinte forma:

    tarefas/
    ├─ e2e/
    ├─ node_modules/
    ├─ src/
    ├─ package.json
    ├─ .angular-cli.json
    ├─ .editorconfig
    ├─ .gitignore
    ├─ karma.conf.js
    ├─ protractor.conf.js
    ├─ README.md
    ├─ tsconfig.json
    └─ tslint.json

    Descritos abaixo:

    O diretório e2e (de end-to-end tests) contém recursos para testarmos a aplicação. Não ficam dentro da pasta src, porque se trata de uma outra aplicação (para testar a sua).
    O diretório node_modules contém todos os pacotes que usaremos, baixados pelo npm. As bibliotecas do Angular também estão instaladas nesse diretório.
    O diretório src contém o código da nossa aplicação e é onde trabalharemos.
    O arquivo package.json contém a lista de pacotes usados na sua aplicação.
    O arquivo .angular-cli.json contém configurações do Angular CLI.
    O arquivo .editorconfig contém configurações para o seu editor compatível com o padrão (ex.: Visual Studio Code).
    O arquivo .gitignore contém a lista de arquivos autogerados que não devem ser exportados para o GIT.
    O arquivo karma.conf.js contém configurações de testes de unidade para o Karma.
    O arquivo protractor.conf.js contém as configurações do framework Protractor de testes end-to-end.
    O arquivo README.md contém a documentação básica do projeto para publicação no repositório.
    O arquivo tsconfig.json contém as configurações do compilador de TypeScript.
    O arquivo tslint.json contém configurações para análise sintática com o TSLint.

Dentro da pasta src a aplicação estará criada com a seguinte estrutura:

    tarefas/
    └─ src/
        ├─ app/
        ├─ assets/
        ├─ favicon.ico
        ├─ index.html
        ├─ main.ts
        ├─ styles.css
        ├─ polyfill.ts
        ├─ test.ts
        ├─ tsconfig.app.json
        ├─ tsconfig.spec.json
        └─ typings.d.ts

    O diretório app é o principal local da nossa aplicação. Entretanto, podemos distribuir o código por outros diretórios, se assim desejarmos.
    O diretório assets é um local para recursos diversos como imagens e arquivos de estilos.
    Os arquivos favicon.ico, index.html e styles.css são aquilo que parecem ser: o ícone, a página principal e uma folha de estilos geral.
    O arquivo main.ts é responsável pela inicialização da nossa aplicação.
    O arquivo polyfill.ts oferece o suporte para os diversos tipos de navegadores. Ele normaliza as diferenças entre eles.
    O arquivo test.ts define o ponto inicial dos testes de unidade.
    Os arquivos tsconfig.app.json e tsconfig.spec.json contêm as configurações de compilação para a aplicação e para os testes de unidade.
    O arquivo typings.d.ts contém declarações personalizadas de tipos Typescript.

    O diretório da nossa aplicação, app contém os arquivos criados automaticamente pelo Angular CLI. São eles:

    tarefas/
    └─ src/
      └─ app/
            ├─ app.module.ts
            ├─ app.component.ts
            ├─ app.component.html
            ├─ app.component.css
            └─ app.component.spec.ts

    Esses são os arquivos principais da nossa aplicação. O arquivo app.component.ts contém o nosso 
    componente principal, AppComponent, responsável por chamar cada um dos outros. 
    Os arquivos app.component.html e app.component.css são os arquivos responsáveis pela visão do
    componente principal e o arquivo app.component.spec.ts é um arquivo usado no teste de unidade 
    do componente principal (todo arquivo .ts terá o arquivo de teste .spec.ts). 
    
    O arquivo app.module.ts contém a estrutura da nossa aplicação, fazendo uma referência para cada 
    um dos outros recursos.  
    Neste momento, o único recurso especificado no módulo é o componente principal AppComponent.

    =====================================================================================================

    Um componente controla um pedaço da página, chamado de visão. Um componente é apenas uma classe e o 
    objetivo dessa classe é apenas gerar HTML. Uma página, construida com vários componentes, será montada
    com a combinação desses componentes.

    Na arquitetura do Angular, um componente controla um pedaço da página web chamado visão. 
    Os componentes, assim, compõem a interface do usuário com a aplicação web. Criaremos alguns componentes 
    que nos permitirão gerar e manipular uma lista de tarefas.

    A visão de cada componente é definida por meio de um template. Um template é um trecho de código HTML que 
    indica ao Angular como apresentar o componente. Um template permite a inserção, no meio do código HTML, 
    de expressões TypeScript que usem dados do componente.

    Os templates são estruturas dinâmicas. Seus conteúdos podem ser atualizados automaticamente, na medida em 
    que o usuário interage com a aplicação.  Para criarmos conteúdo dinâmico, precisamos explicar ao Angular 
    como fazer isso por meio de diretivas. Uma diretiva é uma estrutura que permite a criação de conteúdo dinâmico.

    As diretivas podem ser de estrutura ou de atributos. Uma diretiva de estrutura altera o layout por meio 
    da criação ou remoção de elementos do DOM. Uma diretiva de atributos altera o comportamento de um elemento 
    já existente.

    Sob um ponto de vista técnico, um componente também é uma diretiva, já que cria conteúdos dinâmicos.

    ===========================================================================

    Uma interpolação é a inserção de uma expressão no meio do código HTML. Essa expressão pode ou não usar 
    propriedades e métodos do componente. Expressões interpoladas são delimitadas por chaves duplas {{ e }}.

   Aqui, temos duas expressões interpoladas. Na primeira, interpolamos a propriedade ano. Na segunda, 
   interpolamos a propriedade autor. Nada nos impede, no entanto, de criar uma única expressão da seguinte 
   forma:
    
   <p><small>© {{ano + ' ' + autor}}</small></p> 

   Podemos manter o valor inicial na declaração, como está, ou podemos defini-lo no construtor da classe. 
   O construtor é um método chamado constructor() e é executado imediatamente quando um objeto da classe 
   é criado.

    ======================================================================================

   Os tipos básicos em TypeScript são boolean, number e string. Não há tipos para carateres ou tipos 
   separados para números inteiros e números reais. 

   Podemos criar vetores das seguintes formas:

    * Vetores - Declarados com tipos
    let lista: number[] = [1, 2, 3];
    let lista: Array<number> = [1, 2, 3];

    * Para misturar tipos, usar tuplas
    let cliente: [string, number] = ['José Couves', 35];

    Em ambos os casos, os itens do vetor ou da tupla são acessados por meio dos índices (iniciados em zero). 

    Um tipo particularmente interessante em TypeScript é a enumeração (iniciada em zero ou com valores atribuídos manualmente). Podemos ter, por exemplo, uma enumeração de prioridades da seguinte forma:

    enum prioridade {Baixa, Média, Alta};

    Os valores nessa enumeração são atribuídos automaticamente, sendo 0 para prioridade.Baixa, 1 para prioridade.Média e 2 para prioridade.Alta.

A atribuição manual poderia ser da seguinte forma (em que os valores são meio óbvios):

enum resultado {Insuficiente=40, Regular=60, Bom=80};
Em algumas situações, o valor da variável pode ser desconhecido previamente e precisaremos usar um tipo genérico. A solução para isso é o tipo any. Uma variável desse tipo pode assumir qualquer valor, como nestas atribuições:

let desconhecido: any;
desconhecido = 4; 
desconhecido = "uma string"; 
desconhecido = false;

Quando uma função não retorna valor, o tipo a ser usado é void. Veja este exemplo:

function alerta(msg): void {
  alert(msg);
}
Ocasionalmente, precisaremos converter uma valor de um tipo em um valor de outro tipo. Isso já acontece frequentemente, quando concatenamos uma string e um número. Esse número é convertido automaticamente em string. Mas, em TypeScript, podemos fazer essas coersões de tipos explicitamente de duas formas:

let coisa: any = "esta é uma string"; 
let comprimento: number = (<string>coisa).length;

let coisa: any = "esta é uma string"; 
let comprimento: number = (coisa as string).length;

=============================================================================================

Uma diretiva é uma estrutura que permite a criação de conteúdo dinâmico. Isso significa que ela 
pode alterar a página por meio da criação ou remoção de elementos ou por meio da alteração de 
elementos já existentes. A diretiva que altera a estrutura do documento, criando ou removendo 
elementos, é chamada de diretiva de estrutura. 

O Angular oferece um conjunto de diretivas de estrutura internas que nos ajudam a construir a página. 
São as diretivas NgForOf, NgIf e NgSwitch. A diretiva NgForOf é usada para apresentar coleções de dados, 
como um vetor. 
A diretiva NgIf é usada para apresentar um elemento apenas se uma determinada condição for satisfeita. 
A diretiva NgSwitch nos permite escolher um entre vários elementos, a partir de uma outra condição.


NgForOf
A diretiva NgForOf é usada para criarmos elementos a partir de coleções de dados (como um vetor). 
Elas nos permitem, assim, criar um elemento para cada item da coleção. Veja essa diretiva em uso 
nessa nova versão do arquivo src/app/tarefas.component.ts:

import { Component } from '@angular/core';

@Component({
  selector: 'tarefas',
  template: `
    <ul>
      <li *ngFor="let tarefa of tarefas">{{tarefa}}</li>
    </ul>
  `
})
export class TarefasComponent { 

  tarefas: string[];

  constructor() {
    this.tarefas = [ 
      'Comprar leite',
      'Pagar a conta de luz', 
      'Consertar a cafeteira'
    ];
  }

}

A diretiva NgForOf possui ainda alguns outros valores que podem ser usados nas iterações. 
Os principais são:

index - Variável numérica que indica o índice (iniciado em zero) do item no vetor.
first - Variável lógica que indica se este é o primeiro item do vetor.
last - Variável lógica que indica se este é o último item do vetor.
even - Variável lógica que indica se este item possui um índice par.
odd - Variável lógica que indica se este item possui um índice ímpar.
A instrução a seguir ilustra o uso desses valores:

<li *ngFor="let tarefa of tarefas; index as i">
  {{i+1}} - {{tarefa}}
</li>

===================================================================================================

TEMPLATES HTML

Podemos, finalmente, explicar o porquê dos asteriscos nessas diretivas. 

A HTML possui um elemento chamado template que, a princípio, não carrega nenhum significado. 
Seu objetivo é permitir a marcação de um fragmento de página que não será mostrado imediatamente, 
mas que será usado, em algum momento, por meio de JavaScript. Isso pode ser mostrado por meio do 
seguinte exemplo:

    <table id="tabela">
    <thead>
        <tr>
        <td>Código</td>
        <td>Nome</td>
        </tr>
    </thead>
    <tbody>
        
    </tbody>
    </table>

    <template id="produto">
    <tr>
        <td class="codprod"></td>
        <td class="nomeprod></td>
    </tr>
    </template>


    O template, nesse exemplo, seria usado como modelo para a construção de novas linhas da tabela. 
    A princípio, ele não faz parte do conteúdo da página. Mas, por meio da JavaScript, podemos 
    selecionar esse template cujo atributo id tem o valor produto, gerar uma cópia, preencher seus 
    dados e inseri-lo na tabela.

    O Angular usa um template assim para fazer a inserção ou remoção de elementos no documento HTML. 
    A única diferença, é que o Angular possui uma implementação própria dos templates, ligeiramente 
    diferente da especificação da HTML. Esse elemento é o ng-template e é usado quando escrevemos as 
    diretivas NgFor, NgIf e NgSwitchCase. Os elementos que usam templates são marcados com um *.

    Assim, em Angular, o seguinte código:

    <ul>
    <li *ngFor="let tarefa of tarefas">{{tarefa}}</li>
    </ul>
    
    equivale a:

    <ul>
    <ng-template ngFor let-tarefa [ngForOf]="tarefas">
        <li>{{tarefa}}</li>
    </ng-template>
    </ul>


    Da mesma forma, o código:

    <p *ngIf="tarefas.length==0">
    Parabéns, você não tem tarefa pendente!
    </p>

    equivale a:

    <ng-template [ngIf]="tarefas.length==0">
    <p>
        Parabéns, você não tem tarefa pendente!
    </p>
    </ng-template>
    
    Resumindo, o elemento ng-template encapsula os elementos escritos com diretivas 
    NgFor, NgIf ou NgSwitchCase, permitindo ao Angular assumir o controle sobre a exibição 
    ou não desses elementos.

    ======================================================================================

    Diretivas de atributos

    A diretiva que altera o comportamento de um elemento é chamada de diretiva de atributo. 
    Obviamente, esse termo sugere que o comportamento de um elemento é definido por meio de seus atributos. 
    Veremos agora como criar atributos dinâmicos.

    Antes de ver isso, porém, vamos lembrar rapidamente o uso de interpolações. Uma interpolação insere, 
    no template, uma expressão JavaScript. Essa expressão pode usar uma propriedade ou um método do documento. 
    Por exemplo, poderíamos criar a seguinte interpolação no nosso componente principal, 
    no arquivo src/app/app.component.ts:

    import { Component } from '@angular/core';

    @Component({
        selector: 'app-root',
        template: `
            <p>{{a+" + "+b}} = {{soma()}}</p>
        `
    })
    
    export class AppComponent { 

        a: number = 3;
        b: number = 5;

        soma(): number {
            return this.a+this.b;
        }
    }

    No entanto, a interpolação é usada para criarmos o documento HTML. Esse documento será usado pelo navegador para construir um 
    objeto que representa esse documento - trata-se de um objeto DOM (document object model). 
    A partir daí, a nossa interação é com esse objeto.

    Os elementos de um objeto DOM, no entanto, não possuem atributos. Eles possuem propriedades. Assim, quando interagimos com a 
    página estamos, na verdade, alterando essas propriedades (e não os atributos do documento HTML). 
    A diferença entre alterar atributos e alterar propriedades é relativamente sutil, mas a interação direta com o objeto é mais eficiente. 
    Há, também, uma ligeira diferença entre o conjunto de atributos e o conjunto de propriedades dos elementos da página.

    Enfim, veremos agora como fazer exatamente a mesma coisa acima, porém alterando as propriedades do objeto do documento ao invés 
    dos atributos do código HTML. Para isso, os atributos devem ser delimitados por colchetes.

    import { Component } from '@angular/core';

@Component({
  selector: 'app-root',
  styles: [ '#logo { float: right; }' ],
  template: `
    <div id="logo">
      <p><img [src]="logo" [width]="largura" /></p>
    </div>
  `
})
export class AppComponent { 
  logo: string = '../assets/logo.png';
  largura: number = 150;
}          

Como você pode ver na linha 8, as propriedades são delimitadas por colchetes e as expressões não precisam mais ser encaixadas entre chaves. O resultado, nesse exemplo simples, será o mesmo.

A vantagem dessa notação de colchetes é que ela permite operações mais sofisticadas. Por exemplo, a propriedade style de um elemento é usada para o formatarmos. Por meio desse atributo, temos acesso a todas as propriedades de estilo. Ao invés de fazermos uma definição única da propriedade style, podemos fazer isso separadamente para cada propriedade CSS. Veja a nova versão do componente abaixo.

src/app/app.component.ts
 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
Copiar
import { Component } from '@angular/core';

@Component({
  selector: 'app-root',
  styles: [ '#logo { float: right; }' ],
  template: `
    <div id="logo">
      <p><img [src]="logo" 
              [style.width]="largura"
              [style.margin]="margem" /></p>
    </div>
  `
})
export class AppComponent { 
  logo: string = '../assets/logo.png';
  largura: string = '150px';
  margem: string = '2em';
}          
Nesse código, estamos definindo, separadamente, duas propriedades CSS (linhas 9 e 10). 
Essas propriedades são as mesmas que usaríamos se as estivéssemos acessando diretamente por meio de JavaScript. 
Observe que nas linhas 16 e 27 usamos os valores como em regras CSS (strings). Até agora, estávamos definindo a 
largura da imagem usando um atributo HTML (o que não é uma boa prática).


=================================================================================================================

NgStyle

Apesar de ser interessante (e bastante útil) podermos atribuir propriedades CSS separadamente, muitas vezes será melhor fazer por meio de um único comando. Para isso, podemos usar a diretiva embutida NgStyle. Ela deve receber um objeto contendo as diversas propriedades CSS que desejamos formatar. Veja isso na versão do componente abaixo.

src/app/app.component.ts
 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
Copiar
import { Component } from '@angular/core';

@Component({
  selector: 'app-root',
  styles: [ '#logo { float: right; }' ],
  template: `
    <div id="logo">
      <p><img [src]="logo" 
              [ngStyle]="{
                'width': '150px',
                'margin': '2em'
              }" /></p>
    </div>
  `
})
export class AppComponent { 
  logo: string = '../assets/logo.png';
  largura: string = '150px';
  margem: string = '2em';
}          
O problema dessa declaração (linhas 9 a 12) é que estamos inserindo manualmente a formatação de estilos manualmente no template. Podemos fazer isso de forma ligeiramente mais inteligente criando uma função que retorne esse objeto. Veja agora a alternativa abaixo.

src/app/app.component.ts
 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
Copiar
import { Component } from '@angular/core';

@Component({
  selector: 'app-root',
  styles: [ '#logo { float: right; }' ],
  template: `
    <div id="logo">
      <p><img [src]="logo" 
              [ngStyle]="estilosImagem()" /></p>
    </div>
  `
})
export class AppComponent { 
  logo: string = '../assets/logo.png';
  estilosImagem(): any {
    var estilos = {
      'width': '150px',
      'margin': '2em'
    };
    return estilos;
  }
}
Entre as linhas 15 a 21, criamos o método estilosImagem() que retorna retorna um objeto que contém as definições de estilo. 
Na linha 9, vemos que a diretiva ngStyle recebe uma expressão contendo a chamada ao método estilosImagem().

========================================================================================================================

NgClass

Uma outra diretiva embutida do Angular é a NgClass, que nos permite atribuir mais de uma classe a um determinado elemento 
em uma só operação. Antes disso, vamos ver algumas alternativas. Nós podemos atribuir uma classe a um elemento diretamente 
por meio da diretivaclass. 
Observe que as diretivas recebem uma expressão, assim, a string que será atribuída à diretiva não deve ser o nome da classe 
diretamente, mas uma string interna.

<p [class]="'alerta'">O campo não pode ficar em branco</p>
Nesse exemplo, o parágrafo receberá a classe alerta. Poderíamos ter associado mais de uma classe ao elemento, apenas 
incluindo seus nomes na string interna, separados por espaços:

<p [class]="'alerta mensagem'">O campo não pode ficar em branco</p>
Aqui, o parágrafo receberá duas classes:alerta e mensagem.

Uma alternativa é usarmos um valor lógico para determinar o uso de uma classe. Por exemplo, poderíamos criar o parágrafo 
abaixo ao qual uma classe alerta seria aplicada apenas se a propriedade erro do componente tiver um valor verdadeiro. 
Também poderíamos, alternativamente, ter criado um método que retornasse um valor lógico (segundo parágrafo).

<p [class.alerta]="erro">O campo não pode ficar em branco</p>
<p [class.alerta]="deuErro()">O campo não pode ficar em branco</p>

A diretiva class.alerta associa a classe alerta ao elemento, se ela receber um valor verdadeiro. 
Podemos fazer isso com qualquer outro nome de classe.

Finalmente, podemos mostrar o uso da diretiva NgClass. Essa diretiva tem um comportamento bem semelhante ao da diretiva class, 
mas oferece alguns recursos extras. As formas de uso da diretiva NgClass são:

<p [ngClass]="'classe1 classe2'"> ... </p>
<p [ngClass]="['classe1', 'classe2']"> ... </p>
<p [ngClass]="{'classe1': true, 'classe2': true, 'classe3': false}"> ... </p>
<p [ngClass]="{'classe1 classe2': true, 'classe3': false}"> ... </p>

São muitas alternativas, mas as mais interessantes são as duas últimas. Podemos atribuir ou remover um classe de um elemento 
por meio de um objeto em que cada propriedade corresponde a uma (ou mais) classe que recebe o valor verdadeiro ou falso. 
Se verdadeiro, a classe é associada. Se falso, a classe é removida. Os valores verdadeiro e falso poderiam ser obtidos por meio 
de propriedades ou métodos do componente. Veja o exemplo abaixo.

import { Component } from '@angular/core';

@Component({
  selector: 'app-root',
  styles: [ `
    #logo { 
      float: right; 
    },
    .tamanhoPequeno {
      width: 150px;
      padding: 2em;
    }
    .borda {
      border: thin solid black;
    }
  ` ],
  template: `
    <div id="logo">
      <p><img [src]="logo" 
              [ngClass]="{
                'tamanho': ehPequeno,
                'borda': temBorda()
              }" /></p>
    </div>
  `
})
export class AppComponent { 
  logo: string = '../assets/logo.png';
  ehPequeno = true;
  temborda() { return true };
}
Uma alternativa a esse exemplo seria termos criado um método que retornaria todo o objeto de definição de classes. 
O resultado seria o mesmo.

=======================================================================================================
4.5 Filtros

Partindo do princípio de que toda aplicação deve coletar e apresentar dados, é importante que existam mecanismos para facilitar essas duas operações. No caso da apresentação de dados, o Angular nos oferece um mecanismo de formatação bastante simples: os filtros (pipes).

Um filtro recebe um dado e o transforma em outro dado. Podemos usá-los, por exemplo, para transformarmos uma data do tipo Date em uma string formatada de acordo com o padrão de datas do nosso país. Podemos usá-los também para colocarmos todas as letras de uma string em caixa alta ou baixa e para determinarmos o número de casas decimais de um número.

Os filtros são aplicados usados nas interpolações, a partir da seguinte sintaxe:

{{ expressão | filtro }}
Os filtros podem ser aplicados em cascata:

{{ expressão | filtro1 | filtro2 | ... }}
Os filtros podem conter parâmetros:

{{ expressão | filtro:argumento1:argumento2:... }}

FILTROS EMBUTIDOS

O Angular nos oferece alguns filtros embutidos, para os tipos básicos de valores. Experimente usar esses filtros nos seu componente principal, como mostrado abaixo:

src/app/app.component.ts

import { Component } from '@angular/core';

@Component({
    selector: 'app-root',
    template: `
        <p>{{nome | uppercase}}</p>
        <p>{{nome | lowercase}}</p>
        <p>{{nome | titlecase}}</p>
        <p>{{nome | slice:3:6}}</p>
        <p>{{numero | number:"1.3-3"}}</p>
        <p>{{numero | percent:"1.1-2"}}</p>
        <p>{{moeda | currency:"BRL":true:"1.2-2"}}</p>
        <p>{{data | date:"dd/MM/yyyy"}}</p>
        <pre>{{objeto | json}}</pre>
    `
})
export class AppComponent {
    nome: string = 'PUC Minas';
    numero: number = 0.75;
    moeda: number = 1020.45;
    data: Date = new Date(2017,10,25);
    objeto: any = { login: "josé", senha: "1234"};
}
O filtro de texto pode ser usado para mudar os textos para maiúsculas (uppercase), minúsculas (lowercase) ou apenas iniciais 
maiúsculas (titlecase).

Também podemos usar filtros que recortam ou substituem parte do texto. O filtro slice, no exemplo, retorna a substring do 
quarto ao sétimo caracteres (lembre-se que os índices começam em 0).

O primeiro filtro numérico é number, que possui como parâmetro uma string do tipo n1.n2-n3, em que n1 é o número de dígitos 
antes da vírgula, n2 o número mínimo de casas decimais e n3 o número máximo de casas decimais (há um arredondamento quando o 
número de casas decimais é inferior ao que de fato o número possui).

O segundo filtro numérico é percent, que faz algo semelhante, mas multiplica o valor numérico por 100 e adiciona o símbolo %.

O filtro de moedas, currency, recebe uma indicação da moeda, de acordo com o padrão ISO-4217, um valor lógico que indica se é 
para usar o prefixo de moedas (ex.: R$, US$, ...) e o parâmetro de número de dígitos. Você verá que os formatos numéricos retornam 
números no formato americano (posição dos pontos e vírgulas). Nós podemos alterar isso por meio de um filtro personalizado, que 
veremos adiante.

O filtro de datas, date, permite a formatação de datas em diversos formatos: medium, short, fullDate, longDate, mediumDate, 
shortDate, mediumTime e shortTime. Podemos também, como no exemplo, criar uma máscara para formatação das datas. 
Veja mais sobre essa alternativa na documentação do filtro.

Outro filtro embutido é o json, que formata um objeto para apresentação. É interessante colocar a expressão que usar esse filtro 
dentro de um elemento pre, para que a formatação respeite as quebras de linha e tabulações.


==================================================================================================

4.6 - Eventos

Criar um evento:
  <button (click)="incrementa()">Incrementa</button>

  import { Component } from '@angular/core';

  @Component({
      selector: 'app-root',
      template: `
        <button (click)="incrementa()">Clique aqui.</button>
        <p>{{n}} cliques.</p>
      `
  })
  export class AppComponent { 
    n: number = 0;
    incrementa(): void {
      this.n++;
    }
  }

  Outros Eventos
  import { Component } from '@angular/core';

  @Component({
      selector: 'app-root',
      template: '
        <div id="box" 
            (mouseover)="ativa()" 
            (mouseout)="desativa()"
            [class.sobre]="ativado">
        </div>
      ',
      styles: [ '
        #box {
          width: 150px;
          height: 150px;
          border: thin solid black;
        }
        .sobre {
          background-color: red;
        }
      ']
  })
  export class AppComponent { 
    ativado: boolean = false;
    ativa(): void {
      this.ativado = true;
    }
    desativa(): void {
      this.ativado = false;
    }
  }

  Eventos passados como parâmetro = $event

  import { Component } from '@angular/core';

@Component({
    selector: 'app-root',
    template: `
      <div id="box" 
          (mouseover)="ativa()" 
          (mouseout)="desativa()"
          (mousemove)="movimenta($event)"
          [class.sobre]="ativado">
      </div>
      <p>Coordenadas: {{coords}}</p>
    `,
    styles: [`
      #box {
        width: 150px;
        height: 150px;
        border: thin solid black;
      }
      .sobre {
        background-color: red;
      }
    `]
})
export class AppComponent { 
  ativado: boolean = false;
  coords: string = '';
  ativa(): void {
    this.ativado = true;
  }
  desativa(): void {
    this.ativado = false;
    this.coords = ''; 
  }
  movimenta(e) {
    this.coords = "("+e.clientX+","+e.clientY+")";
  }
}


============================================================================

Formulários

** Pegar o valor do input
import { Component } from '@angular/core';

@Component({
    selector: 'app-root',
    template: `
      <p><input id="nome" name="nome" type="text" /></p>
      <p><button (click)="enviar()">Enviar</button></p>
      <p>Nome: {{nome}}</p>
    `
})
export class AppComponent { 
  nome:string = '';
  enviar(): void {
    this.nome = (<HTMLInputElement>document.getElementById('nome')).value; <<<--
  }
}

** Outra maneira de pegarmos o valor do input
import { Component } from '@angular/core';

@Component({
    selector: 'app-root',
    template: `
      <p><input #n id="nome" name="nome" type="text" /></p>         <<<<--- esse #n é o nome que demos a variável
      <p><button (click)="enviar(n.value)">Enviar</button></p>      <<<<--- que é utilizado aqui e passa o valor do input
      <p>Nome: {{nome}}</p>
    `
})
export class AppComponent { 
  nome:string = '';
  enviar(n): void {
    this.nome = n;                                          <<<--- que é lido aqui
  }
}

==========================================================

Estado dos campos do Formulário

Quando criamos uma ligação bidirecional de dados, por meio da diretiva NgModel, estamos fazendo mais do que associar 
o valor de um campo a uma propriedade do componente. Estamos criando um controle que possui um estado. 
Na seção anterior, vimos o estado valid desse controle. Nesta seção, veremos os outros estados.

Cada controle criado por meio da diretiva NgModel possui seis possíveis estados. Cada um desses estados possui uma 
classe CSS automaticamente associada a ele, de acordo com a seguinte tabela:

Descrição do estado	Propriedade do estado	Classe do estado
O controle foi visitado	touched	ng-touched
O controle não foi visitado	untouched	ng-untouched
O valor do controle foi alterado	dirty	ng-dirty
O valor do controle não foi alterado	pristine	ng-pristine
O valor do controle é válido	valid	ng-valid
O valor do controle não é válido	invalid	ng-invalid
Os dois primeiros estados tratam do controle ter sido ou não visitado. 
Isso significa ter ocorrido alguma interação com o campo, mesmo que o valor tenha permanecido sem alterações. 
Os dois estados seguintes estão relacionados a uma possível alteração do valor do campo, considerando o seu valor 
inicial (do momento da carga do formulário). Os dois últimos estados indicam se o valor do campo atende às regras de 
validação. 
Pode parecer meio óbvio, mas, para cada um desses pares de estado, se o valor de uma propriedade é verdadeiro, 
então o valor da outra é falso. Em outras palavras, se a propriedade dirty for verdadeira, então necessariamente a 
propriedade pristine é falsa e você não precisa fazer os dois testes.


=================================================================================

6 Serviços
Serviços, em Angular, são todas as classes que não estão relacionadas à visão (que é o trabalho dos componentes e das diretivas). 

Um dos exemplos mais tradicionais serviços é a recuperação de dados em um servidor, mas, objetivamente, qualquer operação não 
relacionada à visão deve ser criada como serviço. Um serviço, assim, não deve ter um template. 
Podemos usar serviços para processarmos registrarmos os logs de acesso, para manipularmos dados, para trocarmos mensagens entre 
componentes, para fazermos cálculos, para fazermos configurações da aplicação, para comunicação online e muito mais.

Quando transferimos todas essas operações para os serviços, deixamos os componentes mais limpos e cuidando apenas da interação 
com o usuário. Isso também facilita a atualização da interface sem interferência em classes relacionadas à "lógica do negócio".

Nas próximas seções, veremos como criar dois serviços. Um para gerenciar projetos e outro para gerenciar as tarefas desses projetos.

Os projetos terão apenas dois atributos: codigo e projeto. O codigo será apenas um identificador do projeto e o projeto será o 
nome do projeto propriamente dito.

As tarefas terão mais atributos. Cada uma delas terá também um codigo, uma descrição da tarefa, uma data de conclusão da tarefa 
e uma prioridade (número entre 1 e 3).