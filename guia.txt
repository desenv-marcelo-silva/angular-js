Instalando angular via npm:
    npm install -g @angular/cli

Criar a primeira aplicação:
    ng new tarefas      <<--- tarefas é o nome da aplicação

Ao criar a aplicação com o angular cli, para iniciar um simples servidor e verificar o funcionamento:
    ng serve --open     <<--- Isso irá abrir o browser em http://localhost:4200/

A estrutura de pastas criada ficará da seguinte forma:

    tarefas/
    ├─ e2e/
    ├─ node_modules/
    ├─ src/
    ├─ package.json
    ├─ .angular-cli.json
    ├─ .editorconfig
    ├─ .gitignore
    ├─ karma.conf.js
    ├─ protractor.conf.js
    ├─ README.md
    ├─ tsconfig.json
    └─ tslint.json

    Descritos abaixo:

    O diretório e2e (de end-to-end tests) contém recursos para testarmos a aplicação. Não ficam dentro da pasta src, porque se trata de uma outra aplicação (para testar a sua).
    O diretório node_modules contém todos os pacotes que usaremos, baixados pelo npm. As bibliotecas do Angular também estão instaladas nesse diretório.
    O diretório src contém o código da nossa aplicação e é onde trabalharemos.
    O arquivo package.json contém a lista de pacotes usados na sua aplicação.
    O arquivo .angular-cli.json contém configurações do Angular CLI.
    O arquivo .editorconfig contém configurações para o seu editor compatível com o padrão (ex.: Visual Studio Code).
    O arquivo .gitignore contém a lista de arquivos autogerados que não devem ser exportados para o GIT.
    O arquivo karma.conf.js contém configurações de testes de unidade para o Karma.
    O arquivo protractor.conf.js contém as configurações do framework Protractor de testes end-to-end.
    O arquivo README.md contém a documentação básica do projeto para publicação no repositório.
    O arquivo tsconfig.json contém as configurações do compilador de TypeScript.
    O arquivo tslint.json contém configurações para análise sintática com o TSLint.

Dentro da pasta src a aplicação estará criada com a seguinte estrutura:

    tarefas/
    └─ src/
        ├─ app/
        ├─ assets/
        ├─ favicon.ico
        ├─ index.html
        ├─ main.ts
        ├─ styles.css
        ├─ polyfill.ts
        ├─ test.ts
        ├─ tsconfig.app.json
        ├─ tsconfig.spec.json
        └─ typings.d.ts

    O diretório app é o principal local da nossa aplicação. Entretanto, podemos distribuir o código por outros diretórios, se assim desejarmos.
    O diretório assets é um local para recursos diversos como imagens e arquivos de estilos.
    Os arquivos favicon.ico, index.html e styles.css são aquilo que parecem ser: o ícone, a página principal e uma folha de estilos geral.
    O arquivo main.ts é responsável pela inicialização da nossa aplicação.
    O arquivo polyfill.ts oferece o suporte para os diversos tipos de navegadores. Ele normaliza as diferenças entre eles.
    O arquivo test.ts define o ponto inicial dos testes de unidade.
    Os arquivos tsconfig.app.json e tsconfig.spec.json contêm as configurações de compilação para a aplicação e para os testes de unidade.
    O arquivo typings.d.ts contém declarações personalizadas de tipos Typescript.

    O diretório da nossa aplicação, app contém os arquivos criados automaticamente pelo Angular CLI. São eles:

    tarefas/
    └─ src/
      └─ app/
            ├─ app.module.ts
            ├─ app.component.ts
            ├─ app.component.html
            ├─ app.component.css
            └─ app.component.spec.ts

    Esses são os arquivos principais da nossa aplicação. O arquivo app.component.ts contém o nosso 
    componente principal, AppComponent, responsável por chamar cada um dos outros. 
    Os arquivos app.component.html e app.component.css são os arquivos responsáveis pela visão do
    componente principal e o arquivo app.component.spec.ts é um arquivo usado no teste de unidade 
    do componente principal (todo arquivo .ts terá o arquivo de teste .spec.ts). 
    
    O arquivo app.module.ts contém a estrutura da nossa aplicação, fazendo uma referência para cada 
    um dos outros recursos.  
    Neste momento, o único recurso especificado no módulo é o componente principal AppComponent.

    =====================================================================================================

    Um componente controla um pedaço da página, chamado de visão. Um componente é apenas uma classe e o 
    objetivo dessa classe é apenas gerar HTML. Uma página, construida com vários componentes, será montada
    com a combinação desses componentes.

    Na arquitetura do Angular, um componente controla um pedaço da página web chamado visão. 
    Os componentes, assim, compõem a interface do usuário com a aplicação web. Criaremos alguns componentes 
    que nos permitirão gerar e manipular uma lista de tarefas.

    A visão de cada componente é definida por meio de um template. Um template é um trecho de código HTML que 
    indica ao Angular como apresentar o componente. Um template permite a inserção, no meio do código HTML, 
    de expressões TypeScript que usem dados do componente.

    Os templates são estruturas dinâmicas. Seus conteúdos podem ser atualizados automaticamente, na medida em 
    que o usuário interage com a aplicação.  Para criarmos conteúdo dinâmico, precisamos explicar ao Angular 
    como fazer isso por meio de diretivas. Uma diretiva é uma estrutura que permite a criação de conteúdo dinâmico.

    As diretivas podem ser de estrutura ou de atributos. Uma diretiva de estrutura altera o layout por meio 
    da criação ou remoção de elementos do DOM. Uma diretiva de atributos altera o comportamento de um elemento 
    já existente.

    Sob um ponto de vista técnico, um componente também é uma diretiva, já que cria conteúdos dinâmicos.

    ===========================================================================

    Uma interpolação é a inserção de uma expressão no meio do código HTML. Essa expressão pode ou não usar 
    propriedades e métodos do componente. Expressões interpoladas são delimitadas por chaves duplas {{ e }}.

   Aqui, temos duas expressões interpoladas. Na primeira, interpolamos a propriedade ano. Na segunda, 
   interpolamos a propriedade autor. Nada nos impede, no entanto, de criar uma única expressão da seguinte 
   forma:
    
   <p><small>© {{ano + ' ' + autor}}</small></p> 

   Podemos manter o valor inicial na declaração, como está, ou podemos defini-lo no construtor da classe. 
   O construtor é um método chamado constructor() e é executado imediatamente quando um objeto da classe 
   é criado.

    ======================================================================================

   Os tipos básicos em TypeScript são boolean, number e string. Não há tipos para carateres ou tipos 
   separados para números inteiros e números reais. 

   Podemos criar vetores das seguintes formas:

    * Vetores - Declarados com tipos
    let lista: number[] = [1, 2, 3];
    let lista: Array<number> = [1, 2, 3];

    * Para misturar tipos, usar tuplas
    let cliente: [string, number] = ['José Couves', 35];

    Em ambos os casos, os itens do vetor ou da tupla são acessados por meio dos índices (iniciados em zero). 

    Um tipo particularmente interessante em TypeScript é a enumeração (iniciada em zero ou com valores atribuídos manualmente). Podemos ter, por exemplo, uma enumeração de prioridades da seguinte forma:

    enum prioridade {Baixa, Média, Alta};

    Os valores nessa enumeração são atribuídos automaticamente, sendo 0 para prioridade.Baixa, 1 para prioridade.Média e 2 para prioridade.Alta.

A atribuição manual poderia ser da seguinte forma (em que os valores são meio óbvios):

enum resultado {Insuficiente=40, Regular=60, Bom=80};
Em algumas situações, o valor da variável pode ser desconhecido previamente e precisaremos usar um tipo genérico. A solução para isso é o tipo any. Uma variável desse tipo pode assumir qualquer valor, como nestas atribuições:

let desconhecido: any;
desconhecido = 4; 
desconhecido = "uma string"; 
desconhecido = false;

Quando uma função não retorna valor, o tipo a ser usado é void. Veja este exemplo:

function alerta(msg): void {
  alert(msg);
}
Ocasionalmente, precisaremos converter uma valor de um tipo em um valor de outro tipo. Isso já acontece frequentemente, quando concatenamos uma string e um número. Esse número é convertido automaticamente em string. Mas, em TypeScript, podemos fazer essas coersões de tipos explicitamente de duas formas:

let coisa: any = "esta é uma string"; 
let comprimento: number = (<string>coisa).length;

let coisa: any = "esta é uma string"; 
let comprimento: number = (coisa as string).length;

=============================================================================================

Uma diretiva é uma estrutura que permite a criação de conteúdo dinâmico. Isso significa que ela 
pode alterar a página por meio da criação ou remoção de elementos ou por meio da alteração de 
elementos já existentes. A diretiva que altera a estrutura do documento, criando ou removendo 
elementos, é chamada de diretiva de estrutura. 

O Angular oferece um conjunto de diretivas de estrutura internas que nos ajudam a construir a página. 
São as diretivas NgForOf, NgIf e NgSwitch. A diretiva NgForOf é usada para apresentar coleções de dados, 
como um vetor. 
A diretiva NgIf é usada para apresentar um elemento apenas se uma determinada condição for satisfeita. 
A diretiva NgSwitch nos permite escolher um entre vários elementos, a partir de uma outra condição.


NgForOf
A diretiva NgForOf é usada para criarmos elementos a partir de coleções de dados (como um vetor). 
Elas nos permitem, assim, criar um elemento para cada item da coleção. Veja essa diretiva em uso 
nessa nova versão do arquivo src/app/tarefas.component.ts:

import { Component } from '@angular/core';

@Component({
  selector: 'tarefas',
  template: `
    <ul>
      <li *ngFor="let tarefa of tarefas">{{tarefa}}</li>
    </ul>
  `
})
export class TarefasComponent { 

  tarefas: string[];

  constructor() {
    this.tarefas = [ 
      'Comprar leite',
      'Pagar a conta de luz', 
      'Consertar a cafeteira'
    ];
  }

}

A diretiva NgForOf possui ainda alguns outros valores que podem ser usados nas iterações. 
Os principais são:

index - Variável numérica que indica o índice (iniciado em zero) do item no vetor.
first - Variável lógica que indica se este é o primeiro item do vetor.
last - Variável lógica que indica se este é o último item do vetor.
even - Variável lógica que indica se este item possui um índice par.
odd - Variável lógica que indica se este item possui um índice ímpar.
A instrução a seguir ilustra o uso desses valores:

<li *ngFor="let tarefa of tarefas; index as i">
  {{i+1}} - {{tarefa}}
</li>

===================================================================================================

TEMPLATES HTML

Podemos, finalmente, explicar o porquê dos asteriscos nessas diretivas. 

A HTML possui um elemento chamado template que, a princípio, não carrega nenhum significado. 
Seu objetivo é permitir a marcação de um fragmento de página que não será mostrado imediatamente, 
mas que será usado, em algum momento, por meio de JavaScript. Isso pode ser mostrado por meio do 
seguinte exemplo:

    <table id="tabela">
    <thead>
        <tr>
        <td>Código</td>
        <td>Nome</td>
        </tr>
    </thead>
    <tbody>
        
    </tbody>
    </table>

    <template id="produto">
    <tr>
        <td class="codprod"></td>
        <td class="nomeprod></td>
    </tr>
    </template>


    O template, nesse exemplo, seria usado como modelo para a construção de novas linhas da tabela. 
    A princípio, ele não faz parte do conteúdo da página. Mas, por meio da JavaScript, podemos 
    selecionar esse template cujo atributo id tem o valor produto, gerar uma cópia, preencher seus 
    dados e inseri-lo na tabela.

    O Angular usa um template assim para fazer a inserção ou remoção de elementos no documento HTML. 
    A única diferença, é que o Angular possui uma implementação própria dos templates, ligeiramente 
    diferente da especificação da HTML. Esse elemento é o ng-template e é usado quando escrevemos as 
    diretivas NgFor, NgIf e NgSwitchCase. Os elementos que usam templates são marcados com um *.

    Assim, em Angular, o seguinte código:

    <ul>
    <li *ngFor="let tarefa of tarefas">{{tarefa}}</li>
    </ul>
    
    equivale a:

    <ul>
    <ng-template ngFor let-tarefa [ngForOf]="tarefas">
        <li>{{tarefa}}</li>
    </ng-template>
    </ul>


    Da mesma forma, o código:

    <p *ngIf="tarefas.length==0">
    Parabéns, você não tem tarefa pendente!
    </p>

    equivale a:

    <ng-template [ngIf]="tarefas.length==0">
    <p>
        Parabéns, você não tem tarefa pendente!
    </p>
    </ng-template>
    
    Resumindo, o elemento ng-template encapsula os elementos escritos com diretivas 
    NgFor, NgIf ou NgSwitchCase, permitindo ao Angular assumir o controle sobre a exibição 
    ou não desses elementos.

    ======================================================================================

    Diretivas de atributos

    A diretiva que altera o comportamento de um elemento é chamada de diretiva de atributo. 
    Obviamente, esse termo sugere que o comportamento de um elemento é definido por meio de seus atributos. 
    Veremos agora como criar atributos dinâmicos.

    Antes de ver isso, porém, vamos lembrar rapidamente o uso de interpolações. Uma interpolação insere, 
    no template, uma expressão JavaScript. Essa expressão pode usar uma propriedade ou um método do documento. 
    Por exemplo, poderíamos criar a seguinte interpolação no nosso componente principal, 
    no arquivo src/app/app.component.ts:

    import { Component } from '@angular/core';

    @Component({
        selector: 'app-root',
        template: `
            <p>{{a+" + "+b}} = {{soma()}}</p>
        `
    })
    
    export class AppComponent { 

        a: number = 3;
        b: number = 5;

        soma(): number {
            return this.a+this.b;
        }
    }

    No entanto, a interpolação é usada para criarmos o documento HTML. Esse documento será usado pelo navegador para construir um 
    objeto que representa esse documento - trata-se de um objeto DOM (document object model). 
    A partir daí, a nossa interação é com esse objeto.

    Os elementos de um objeto DOM, no entanto, não possuem atributos. Eles possuem propriedades. Assim, quando interagimos com a 
    página estamos, na verdade, alterando essas propriedades (e não os atributos do documento HTML). 
    A diferença entre alterar atributos e alterar propriedades é relativamente sutil, mas a interação direta com o objeto é mais eficiente. 
    Há, também, uma ligeira diferença entre o conjunto de atributos e o conjunto de propriedades dos elementos da página.

    Enfim, veremos agora como fazer exatamente a mesma coisa acima, porém alterando as propriedades do objeto do documento ao invés 
    dos atributos do código HTML. Para isso, os atributos devem ser delimitados por colchetes.

    import { Component } from '@angular/core';

@Component({
  selector: 'app-root',
  styles: [ '#logo { float: right; }' ],
  template: `
    <div id="logo">
      <p><img [src]="logo" [width]="largura" /></p>
    </div>
  `
})
export class AppComponent { 
  logo: string = '../assets/logo.png';
  largura: number = 150;
}          

Como você pode ver na linha 8, as propriedades são delimitadas por colchetes e as expressões não precisam mais ser encaixadas entre chaves. O resultado, nesse exemplo simples, será o mesmo.

A vantagem dessa notação de colchetes é que ela permite operações mais sofisticadas. Por exemplo, a propriedade style de um elemento é usada para o formatarmos. Por meio desse atributo, temos acesso a todas as propriedades de estilo. Ao invés de fazermos uma definição única da propriedade style, podemos fazer isso separadamente para cada propriedade CSS. Veja a nova versão do componente abaixo.

src/app/app.component.ts
 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
Copiar
import { Component } from '@angular/core';

@Component({
  selector: 'app-root',
  styles: [ '#logo { float: right; }' ],
  template: `
    <div id="logo">
      <p><img [src]="logo" 
              [style.width]="largura"
              [style.margin]="margem" /></p>
    </div>
  `
})
export class AppComponent { 
  logo: string = '../assets/logo.png';
  largura: string = '150px';
  margem: string = '2em';
}          
Nesse código, estamos definindo, separadamente, duas propriedades CSS (linhas 9 e 10). 
Essas propriedades são as mesmas que usaríamos se as estivéssemos acessando diretamente por meio de JavaScript. 
Observe que nas linhas 16 e 27 usamos os valores como em regras CSS (strings). Até agora, estávamos definindo a 
largura da imagem usando um atributo HTML (o que não é uma boa prática).


=================================================================================================================

NgStyle

Apesar de ser interessante (e bastante útil) podermos atribuir propriedades CSS separadamente, muitas vezes será melhor fazer por meio de um único comando. Para isso, podemos usar a diretiva embutida NgStyle. Ela deve receber um objeto contendo as diversas propriedades CSS que desejamos formatar. Veja isso na versão do componente abaixo.

src/app/app.component.ts
 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
Copiar
import { Component } from '@angular/core';

@Component({
  selector: 'app-root',
  styles: [ '#logo { float: right; }' ],
  template: `
    <div id="logo">
      <p><img [src]="logo" 
              [ngStyle]="{
                'width': '150px',
                'margin': '2em'
              }" /></p>
    </div>
  `
})
export class AppComponent { 
  logo: string = '../assets/logo.png';
  largura: string = '150px';
  margem: string = '2em';
}          
O problema dessa declaração (linhas 9 a 12) é que estamos inserindo manualmente a formatação de estilos manualmente no template. Podemos fazer isso de forma ligeiramente mais inteligente criando uma função que retorne esse objeto. Veja agora a alternativa abaixo.

src/app/app.component.ts
 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
Copiar
import { Component } from '@angular/core';

@Component({
  selector: 'app-root',
  styles: [ '#logo { float: right; }' ],
  template: `
    <div id="logo">
      <p><img [src]="logo" 
              [ngStyle]="estilosImagem()" /></p>
    </div>
  `
})
export class AppComponent { 
  logo: string = '../assets/logo.png';
  estilosImagem(): any {
    var estilos = {
      'width': '150px',
      'margin': '2em'
    };
    return estilos;
  }
}
Entre as linhas 15 a 21, criamos o método estilosImagem() que retorna retorna um objeto que contém as definições de estilo. 
Na linha 9, vemos que a diretiva ngStyle recebe uma expressão contendo a chamada ao método estilosImagem().

========================================================================================================================

NgClass

Uma outra diretiva embutida do Angular é a NgClass, que nos permite atribuir mais de uma classe a um determinado elemento 
em uma só operação. Antes disso, vamos ver algumas alternativas. Nós podemos atribuir uma classe a um elemento diretamente 
por meio da diretivaclass. 
Observe que as diretivas recebem uma expressão, assim, a string que será atribuída à diretiva não deve ser o nome da classe 
diretamente, mas uma string interna.

<p [class]="'alerta'">O campo não pode ficar em branco</p>
Nesse exemplo, o parágrafo receberá a classe alerta. Poderíamos ter associado mais de uma classe ao elemento, apenas 
incluindo seus nomes na string interna, separados por espaços:

<p [class]="'alerta mensagem'">O campo não pode ficar em branco</p>
Aqui, o parágrafo receberá duas classes:alerta e mensagem.

Uma alternativa é usarmos um valor lógico para determinar o uso de uma classe. Por exemplo, poderíamos criar o parágrafo 
abaixo ao qual uma classe alerta seria aplicada apenas se a propriedade erro do componente tiver um valor verdadeiro. 
Também poderíamos, alternativamente, ter criado um método que retornasse um valor lógico (segundo parágrafo).

<p [class.alerta]="erro">O campo não pode ficar em branco</p>
<p [class.alerta]="deuErro()">O campo não pode ficar em branco</p>

A diretiva class.alerta associa a classe alerta ao elemento, se ela receber um valor verdadeiro. 
Podemos fazer isso com qualquer outro nome de classe.

Finalmente, podemos mostrar o uso da diretiva NgClass. Essa diretiva tem um comportamento bem semelhante ao da diretiva class, 
mas oferece alguns recursos extras. As formas de uso da diretiva NgClass são:

<p [ngClass]="'classe1 classe2'"> ... </p>
<p [ngClass]="['classe1', 'classe2']"> ... </p>
<p [ngClass]="{'classe1': true, 'classe2': true, 'classe3': false}"> ... </p>
<p [ngClass]="{'classe1 classe2': true, 'classe3': false}"> ... </p>

São muitas alternativas, mas as mais interessantes são as duas últimas. Podemos atribuir ou remover um classe de um elemento 
por meio de um objeto em que cada propriedade corresponde a uma (ou mais) classe que recebe o valor verdadeiro ou falso. 
Se verdadeiro, a classe é associada. Se falso, a classe é removida. Os valores verdadeiro e falso poderiam ser obtidos por meio 
de propriedades ou métodos do componente. Veja o exemplo abaixo.

import { Component } from '@angular/core';

@Component({
  selector: 'app-root',
  styles: [ `
    #logo { 
      float: right; 
    },
    .tamanhoPequeno {
      width: 150px;
      padding: 2em;
    }
    .borda {
      border: thin solid black;
    }
  ` ],
  template: `
    <div id="logo">
      <p><img [src]="logo" 
              [ngClass]="{
                'tamanho': ehPequeno,
                'borda': temBorda()
              }" /></p>
    </div>
  `
})
export class AppComponent { 
  logo: string = '../assets/logo.png';
  ehPequeno = true;
  temborda() { return true };
}
Uma alternativa a esse exemplo seria termos criado um método que retornaria todo o objeto de definição de classes. 
O resultado seria o mesmo.

=======================================================================================================
4.5 Filtros

Partindo do princípio de que toda aplicação deve coletar e apresentar dados, é importante que existam mecanismos para facilitar essas duas operações. No caso da apresentação de dados, o Angular nos oferece um mecanismo de formatação bastante simples: os filtros (pipes).

Um filtro recebe um dado e o transforma em outro dado. Podemos usá-los, por exemplo, para transformarmos uma data do tipo Date em uma string formatada de acordo com o padrão de datas do nosso país. Podemos usá-los também para colocarmos todas as letras de uma string em caixa alta ou baixa e para determinarmos o número de casas decimais de um número.

Os filtros são aplicados usados nas interpolações, a partir da seguinte sintaxe:

{{ expressão | filtro }}
Os filtros podem ser aplicados em cascata:

{{ expressão | filtro1 | filtro2 | ... }}
Os filtros podem conter parâmetros:

{{ expressão | filtro:argumento1:argumento2:... }}

FILTROS EMBUTIDOS

O Angular nos oferece alguns filtros embutidos, para os tipos básicos de valores. Experimente usar esses filtros nos seu componente principal, como mostrado abaixo:

src/app/app.component.ts

import { Component } from '@angular/core';

@Component({
    selector: 'app-root',
    template: `
        <p>{{nome | uppercase}}</p>
        <p>{{nome | lowercase}}</p>
        <p>{{nome | titlecase}}</p>
        <p>{{nome | slice:3:6}}</p>
        <p>{{numero | number:"1.3-3"}}</p>
        <p>{{numero | percent:"1.1-2"}}</p>
        <p>{{moeda | currency:"BRL":true:"1.2-2"}}</p>
        <p>{{data | date:"dd/MM/yyyy"}}</p>
        <pre>{{objeto | json}}</pre>
    `
})
export class AppComponent {
    nome: string = 'PUC Minas';
    numero: number = 0.75;
    moeda: number = 1020.45;
    data: Date = new Date(2017,10,25);
    objeto: any = { login: "josé", senha: "1234"};
}
O filtro de texto pode ser usado para mudar os textos para maiúsculas (uppercase), minúsculas (lowercase) ou apenas iniciais 
maiúsculas (titlecase).

Também podemos usar filtros que recortam ou substituem parte do texto. O filtro slice, no exemplo, retorna a substring do 
quarto ao sétimo caracteres (lembre-se que os índices começam em 0).

O primeiro filtro numérico é number, que possui como parâmetro uma string do tipo n1.n2-n3, em que n1 é o número de dígitos 
antes da vírgula, n2 o número mínimo de casas decimais e n3 o número máximo de casas decimais (há um arredondamento quando o 
número de casas decimais é inferior ao que de fato o número possui).

O segundo filtro numérico é percent, que faz algo semelhante, mas multiplica o valor numérico por 100 e adiciona o símbolo %.

O filtro de moedas, currency, recebe uma indicação da moeda, de acordo com o padrão ISO-4217, um valor lógico que indica se é 
para usar o prefixo de moedas (ex.: R$, US$, ...) e o parâmetro de número de dígitos. Você verá que os formatos numéricos retornam 
números no formato americano (posição dos pontos e vírgulas). Nós podemos alterar isso por meio de um filtro personalizado, que 
veremos adiante.

O filtro de datas, date, permite a formatação de datas em diversos formatos: medium, short, fullDate, longDate, mediumDate, 
shortDate, mediumTime e shortTime. Podemos também, como no exemplo, criar uma máscara para formatação das datas. 
Veja mais sobre essa alternativa na documentação do filtro.

Outro filtro embutido é o json, que formata um objeto para apresentação. É interessante colocar a expressão que usar esse filtro 
dentro de um elemento pre, para que a formatação respeite as quebras de linha e tabulações.


==================================================================================================

4.6 - Eventos

Criar um evento:
  <button (click)="incrementa()">Incrementa</button>

  import { Component } from '@angular/core';

  @Component({
      selector: 'app-root',
      template: `
        <button (click)="incrementa()">Clique aqui.</button>
        <p>{{n}} cliques.</p>
      `
  })
  export class AppComponent { 
    n: number = 0;
    incrementa(): void {
      this.n++;
    }
  }

  Outros Eventos
  import { Component } from '@angular/core';

  @Component({
      selector: 'app-root',
      template: '
        <div id="box" 
            (mouseover)="ativa()" 
            (mouseout)="desativa()"
            [class.sobre]="ativado">
        </div>
      ',
      styles: [ '
        #box {
          width: 150px;
          height: 150px;
          border: thin solid black;
        }
        .sobre {
          background-color: red;
        }
      ']
  })
  export class AppComponent { 
    ativado: boolean = false;
    ativa(): void {
      this.ativado = true;
    }
    desativa(): void {
      this.ativado = false;
    }
  }

  Eventos passados como parâmetro = $event

  import { Component } from '@angular/core';

@Component({
    selector: 'app-root',
    template: `
      <div id="box" 
          (mouseover)="ativa()" 
          (mouseout)="desativa()"
          (mousemove)="movimenta($event)"
          [class.sobre]="ativado">
      </div>
      <p>Coordenadas: {{coords}}</p>
    `,
    styles: [`
      #box {
        width: 150px;
        height: 150px;
        border: thin solid black;
      }
      .sobre {
        background-color: red;
      }
    `]
})
export class AppComponent { 
  ativado: boolean = false;
  coords: string = '';
  ativa(): void {
    this.ativado = true;
  }
  desativa(): void {
    this.ativado = false;
    this.coords = ''; 
  }
  movimenta(e) {
    this.coords = "("+e.clientX+","+e.clientY+")";
  }
}


============================================================================

Formulários

** Pegar o valor do input
import { Component } from '@angular/core';

@Component({
    selector: 'app-root',
    template: `
      <p><input id="nome" name="nome" type="text" /></p>
      <p><button (click)="enviar()">Enviar</button></p>
      <p>Nome: {{nome}}</p>
    `
})
export class AppComponent { 
  nome:string = '';
  enviar(): void {
    this.nome = (<HTMLInputElement>document.getElementById('nome')).value; <<<--
  }
}

** Outra maneira de pegarmos o valor do input
import { Component } from '@angular/core';

@Component({
    selector: 'app-root',
    template: `
      <p><input #n id="nome" name="nome" type="text" /></p>         <<<<--- esse #n é o nome que demos a variável
      <p><button (click)="enviar(n.value)">Enviar</button></p>      <<<<--- que é utilizado aqui e passa o valor do input
      <p>Nome: {{nome}}</p>
    `
})
export class AppComponent { 
  nome:string = '';
  enviar(n): void {
    this.nome = n;                                          <<<--- que é lido aqui
  }
}

==========================================================

Estado dos campos do Formulário

Quando criamos uma ligação bidirecional de dados, por meio da diretiva NgModel, estamos fazendo mais do que associar 
o valor de um campo a uma propriedade do componente. Estamos criando um controle que possui um estado. 
Na seção anterior, vimos o estado valid desse controle. Nesta seção, veremos os outros estados.

Cada controle criado por meio da diretiva NgModel possui seis possíveis estados. Cada um desses estados possui uma 
classe CSS automaticamente associada a ele, de acordo com a seguinte tabela:

Descrição do estado	Propriedade do estado	Classe do estado
O controle foi visitado	touched	ng-touched
O controle não foi visitado	untouched	ng-untouched
O valor do controle foi alterado	dirty	ng-dirty
O valor do controle não foi alterado	pristine	ng-pristine
O valor do controle é válido	valid	ng-valid
O valor do controle não é válido	invalid	ng-invalid
Os dois primeiros estados tratam do controle ter sido ou não visitado. 
Isso significa ter ocorrido alguma interação com o campo, mesmo que o valor tenha permanecido sem alterações. 
Os dois estados seguintes estão relacionados a uma possível alteração do valor do campo, considerando o seu valor 
inicial (do momento da carga do formulário). Os dois últimos estados indicam se o valor do campo atende às regras de 
validação. 
Pode parecer meio óbvio, mas, para cada um desses pares de estado, se o valor de uma propriedade é verdadeiro, 
então o valor da outra é falso. Em outras palavras, se a propriedade dirty for verdadeira, então necessariamente a 
propriedade pristine é falsa e você não precisa fazer os dois testes.


=================================================================================

6 Serviços
Serviços, em Angular, são todas as classes que não estão relacionadas à visão (que é o trabalho dos componentes e das diretivas). 

Um dos exemplos mais tradicionais serviços é a recuperação de dados em um servidor, mas, objetivamente, qualquer operação não 
relacionada à visão deve ser criada como serviço. Um serviço, assim, não deve ter um template. 
Podemos usar serviços para processarmos registrarmos os logs de acesso, para manipularmos dados, para trocarmos mensagens entre 
componentes, para fazermos cálculos, para fazermos configurações da aplicação, para comunicação online e muito mais.

Quando transferimos todas essas operações para os serviços, deixamos os componentes mais limpos e cuidando apenas da interação 
com o usuário. Isso também facilita a atualização da interface sem interferência em classes relacionadas à "lógica do negócio".

Nas próximas seções, veremos como criar dois serviços. Um para gerenciar projetos e outro para gerenciar as tarefas desses projetos.

Os projetos terão apenas dois atributos: codigo e projeto. O codigo será apenas um identificador do projeto e o projeto será o 
nome do projeto propriamente dito.

As tarefas terão mais atributos. Cada uma delas terá também um codigo, uma descrição da tarefa, uma data de conclusão da tarefa 
e uma prioridade (número entre 1 e 3).


===============================================================

6.2 Injeção de Dependências

A injeção de dependências é uma forma de se oferecer uma instância de uma classe para outra, reduzindo a amarração entre os 
códigos das duas classes, o que facilita bastante a sua manutenção.

Acima de tudo, a injeção de dependências é um padrão de projeto (obrigatório em Angular). 
Veja, por exemplo, como seria uma criação típica de objetos em TypeScript sem a injeção de dependências:

export class TarefasComponent {

  public ts: TarefasService;

  constructor() {
    this.ts = new TarefasService();
  }

}


Esse código coloca a criação do objeto TarefasService dentro do construtor da classe TarefasComponent. 
Isso torna essa classe mais complexa e difícil de testar. O melhor seria retirar essa criação do serviço de tarefas 
de dentro da classe TarefasComponent e fazer com que ela receba esse objeto já pronto para uso, após ter sido criado 
em algum outro lugar (que não deve ser da nossa preocupação, neste momento).

A injeção de dependências faz basicamente isso, criar um mecanismo em que essas dependências de outros objetos sejam 
resolvidas automaticamente. Quando forem criados, de alguma forma, os objetos são injetados no construtor da classe 
que precisa deles. Assim, o código poderia ser reescrito para ficar como:

export class TarefasComponent {

  constructor(public ts: TarefasService) { }

}

O que está acontecendo aqui é que o objeto ts do tipo TarefasService é criada em algum lugar e passado como parâmetro 
para o construtor da classe TarefasComponent.

Esse código apenas tem um detalhe extra. Quando associamos os modificadores de acesso public ou private a um parâmetro 
do construtor, estamos tornando esse parâmetro uma propriedade da classe. Em outras palavras, esse código tem exatamente 
o mesmo comportamento que esse próximo:

export class TarefasComponent {

  public ts: TarefasService;

  constructor(ts: TarefasService) {
    this.ts = ts;
  }
}
A única diferença, como você pode perceber, é que o código anterior é mais limpo. Em ambos os casos, o objeto 
this.ts estará disponível para os outros métodos.


PROVIDERS

Antes de passarmos ao próximo assunto, ainda há dois outros ajustes necessários para que um objeto possa ser 
injetado em uma classe. O primeiro é transformá-lo em um objeto do tipo Injectable. 
Fizemos isso na seção anterior, quando aplicamos o decorator Injectable às classes TarefasService e ProjetosService. 
A segunda operação é incluir esses serviços no módulo da aplicação, para que a aplicação os reconheças e saiba onde localizá-los.


===============================================================================================

7 Roteamento
Até o momento, colocamos nossos dois componentes dentro do template do componente principal, por meio de seus elementos. 
Precisamos, porém, de um sistema de navegação para que possamos mostrar um ou outro componente, de acordo com a necessidade.

Esse sistema de navegação é chamado, em Angular, de roteamento. Quem cuida dessa operação é um objeto chamado Router. 
De uma forma bem básica, o que esse roteador faz é definir qual componente deve ser apresentado a partir do URL informado 
no navegador (seja por meio de digitação, seja por meio da navegação por um link).

Note que, no caso de uma aplicação de página única, como a que estamos desenvolvendo, só há uma página, que é a página principal. 
Mas essa página permite a exibição de qualquer combinação de componentes. E quem determinará o(s) componente(s) a ser(em) 
exibido(s) é o Router.

A única regra obrigatória para que o Router funcione é a definição do diretório de referência para os URLs relativos. 
Fazemos isso por meio da seguinte declaração no cabeçalho do arquivo index.html:

<base href="/" />

Nós definimos as rotas da nossa aplicação na declaração do módulo, isto é, no arquivo src/app/app.module.ts. As rotas são declaradas como um objeto da classe Routes e inseridas no módulo por meio do método RouteModule.forRoot(). Essas duas classes fazem parte da biblioteca @angular/router.

Uma rota é composta por pelo menos as seguintes duas propriedades:

path - Caminho a ser usado no URL e que será associado a um componente;
component - Componente associado a esse caminho.
Assim, podemos criar as seguintes rotas para os nossos dois componentes:

const rotas: Routes = [
  {path: 'projetos',  component: ProjetosComponent},
  {path: 'tarefas',   component: TarefasComponent}
];
Essas rotas serão, respectivamente, associadas aos URLs:

/projetos
/tarefas
Podemos criar ainda alguns outros tipos de rotas. Por exemplo, suponha que precisemos de uma rota para um projeto específico de código 3 ou para a tarefa de código 7. Nesses casos, teremos os seguintes URLs:

/projetos/3
/tarefas/7
Esses URLs não serão atendidos pelas rotas acima. Também não é possível criar uma rota específica para cada código de projeto ou tarefa por razões óbvias. Assim, precisamos encaixar uma espécie de variável na rota. Fazemos isso da seguinte forma:

const rotas: Routes = [
  {path: 'projetos',     component: ProjetosComponent},
  {path: 'tarefas',      component: TarefasComponent}
  {path: 'projetos/:id', component: ProjetoComponent}
  {path: 'tarefas/:id',  component: TarefaComponent}
];
Observe que estamos indicando outros dois componentes para cuidar dessas novas rotas. Esses componentes apresentarão um projeto e uma tarefa específicas, que será determinada a partir do :id extraído do URL. Veremos, adiante, como fazer isso. Por enquanto, nos concentraremos na criação das rotas.

Há mais três aspectos interessantes sobre as rotas. O primeiro deles é que podemos associar dados estáticos a uma rota. Podemos usar isso de acordo com a conveniência. Por exemplo, podemos criar um título para a página:

const rotas: Routes = [
  {
    path: 'projetos', 
    component: ProjetosComponent,
    data: { titulo: 'lista de projetos'}
  }
];
Podemos também criar uma rota inicial, isto é, quando o URL não tiver nenhum caminho especial. Para isso, usamos uma string vazia, como no seguinte exemplo:

const rotas: Routes = [
  {
    path: '', 
    redirectTo: '/projetos',
    pathMatch: 'full'
  }
];
A propriedade redirectTo indica qual rota deve ser seguida nesse caso. Assim, o caminho / será automaticamente substituído pelo caminho /projetos. A propriedade pathMatch estabelece que a comparação dos caminhos deve ser completa. Caso contrário qualquer rota poderia ser equivalente a uma string vazia.

Finalmente, podemos criar uma rota para URLs inválidos. Para isso, usamos o caminho ** que funciona como um curinga. Então, basta criarmos um componente que apresente uma página vazia (uma página 404). O exemplo abaixo ilustra isso:

const rotas: Routes = [
  {
    path: '**', 
    component: PaginaInvalidaComponent
  }
];

=======================================================================================================================

Para que possamos ver o sistema de roteamento funcionando, precisamos definir o ponto do template do componente principal 
em que os componentes serão inseridos. De uma forma geral, isso funciona como se estivéssemos inserindo um componente qualquer.

Por exemplo, para inserirmos o componente de projetos no componente principal, acrescentamos o seguinte elemento ao seu template:

<projetos></projetos>
O sistema de roteamento, no entanto, escolhe um elemento diferente para apresentação a cada momento, de acordo com o URL 
informado no navegador. Portanto, não podemos fazer uma inserção direta de um componente como acima. 
Precisamos de um outro recurso que identifique o componente ativo no sistema de roteamento. 
Para isso, usamos o seguinte elemento no template:

<router-outlet></router-outlet>
Antes de inserirmos esse elemento no template, vamos ver como podemos criar links usando o sistema de roteamento. 

Um link tradicional poderia ser criado da seguinte forma:

<a href="/projetos">Projetos</a>
O problema desse formato de link é que ele força a recarga da aplicação 
(experimente inseri-lo no template do componente principal). 
Uma aplicação web de página única, como as que o Angular nos permite criar, não deve recarregar a página. 
Tudo deve acontecer por meio da troca de conteúdo (usando AJAX). 
Assim, vamos usar uma outra forma de criar links. Usaremos a diretiva routerLink, como abaixo:

<h1>Gestão de Tarefas</h1>
<nav>
  <a routerLink="/tarefas" routerLinkActive="ativo">Tarefas</a>
  <a routerLink="/projetos" routerLinkActive="ativo">Projetos</a>
</nav>
<router-outlet></router-outlet>
<copyright></copyright>
A diretiva routerLink funciona exatamente como o atributo href. A diferença é que a carga será feita por meio de AJAX.

Observe que os links possuem uma outra diretiva: routerLinkActive. 
Essa diretiva permite que associemos uma classe ao link ativo (e apenas a ele). 
Assim, podemos formatar o link ativo de uma forma especial.